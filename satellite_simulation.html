<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Satellite Orbital Simulation - Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            /* Default Classic Theme Variables */
            --primary-bg: #001122;
            --secondary-bg: rgba(0, 17, 34, 0.95);
            --tertiary-bg: rgba(0, 0, 0, 0.8);
            --primary-text: #00ff00;
            --secondary-text: #00ff88;
            --accent-text: #00ccff;
            --border-color: #00ff00;
            --hover-bg: rgba(0, 255, 0, 0.1);
            --panel-bg: rgba(0, 17, 34, 0.9);
            --button-bg: #003300;
            --button-hover: #004400;
            --button-active: #006600;
            --input-bg: #003300;
            --shadow-color: rgba(0, 255, 0, 0.3);
            --error-color: #ff3333;
            --warning-color: #ffff33;
            --success-color: #50fa7b;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--primary-bg);
            color: var(--primary-text);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        /* Left Sidebar Tray */
        #sidebar-tray {
            position: fixed;
            top: 0;
            left: 0;
            width: 320px;
            height: 100vh;
            background: var(--panel-bg);
            border-right: 2px solid var(--border-color);
            backdrop-filter: blur(10px);
            z-index: 1000;
            transition: transform 0.3s ease;
            transform: translateX(0);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        
        #sidebar-tray.retracted {
            transform: translateX(-280px);
        }
        
        #sidebar-toggle {
            position: absolute;
            top: 50%;
            right: -40px;
            width: 40px;
            height: 80px;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            border-left: none;
            border-radius: 0 8px 8px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: var(--primary-text);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            transform: translateY(-50%);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
        }
        
        #sidebar-toggle:hover {
            background: var(--button-hover);
            color: var(--secondary-text);
        }
        
        #sidebar-content {
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: var(--primary-text);
        }
        
        .sidebar-section {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .sidebar-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .sidebar-section h3 {
            color: var(--secondary-text);
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button {
            background: var(--button-bg);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        
        button:hover {
            background: var(--button-hover);
        }
        
        button.active {
            background: var(--button-active);
            border-color: var(--secondary-text);
        }
        
        #camera-presets {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 3px;
            margin-bottom: 8px;
        }
        
        #camera-presets button {
            font-size: 9px;
            padding: 4px 6px;
        }
        
        #follow-objects {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 3px;
            margin-bottom: 8px;
        }
        
        #follow-objects button {
            font-size: 8px;
            padding: 3px 4px;
        }
        
        #follow-objects #stop-follow {
            grid-column: 1 / -1;
            font-size: 9px;
            padding: 4px 6px;
        }
        
        input {
            background: var(--input-bg);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            padding: 4px;
            margin: 2px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            width: 50px;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
        }
        
        input[type="range"] {
            width: 100px;
            height: 15px;
            background: var(--input-bg);
        }
        
        .slider-value {
            font-size: 9px;
            color: var(--secondary-text);
            margin-left: 5px;
            min-width: 30px;
            display: inline-block;
            text-align: right;
            transition: color 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary-text);
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--primary-text);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .config-row {
            display: flex;
            align-items: center;
            margin: 5px 0;
            justify-content: space-between;
        }
        
        .config-row label {
            flex: 1;
            font-size: 10px;
        }
        
        .satellite-class-label {
            cursor: pointer;
            user-select: none;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        
        .satellite-class-label:hover {
            background-color: var(--button-hover);
        }
        
        .satellite-class-label:active {
            background-color: var(--button-active);
        }
        
        .status-fail { color: var(--error-color); }
        .status-comm { color: #3333ff; }
        .status-nav { color: var(--warning-color); }
        .status-weather { color: var(--accent-text); }
        .status-military { color: #ff33ff; }
    </style>
</head>
<body>
    <!-- Left Sidebar Tray -->
    <div id="sidebar-tray">
        <div id="sidebar-toggle" onclick="toggleSidebar()">‚óÄ</div>
        <div id="sidebar-content">
            
            <!-- System Info Section -->
            <div class="sidebar-section">
                <h3>üì° SAT-SOL-SIM</h3>
        <div id="satellite-count">Active Satellites: 0</div>
        <div id="failed-count">Failed Satellites: 0</div>
                <div id="camera-info">Camera: Earth Close</div>
        <div id="camera-mode">Mode: Preset | Follow: Off</div>
        <div id="celestial-info">‚òÄÔ∏è Sun | ‚òø Mercury | ‚ôÄ Venus | üåç Earth | ‚ôÇ Mars | ‚ôÉ Jupiter | ‚ôÑ Saturn | ‚õ¢ Uranus | ‚ôÜ Neptune</div>
        <div id="selected-info">Click satellite for details</div>
    </div>
    
            <!-- Camera Controls Section -->
            <div class="sidebar-section">
                <h3>üìπ Camera Controls</h3>
                <div id="camera-presets">
                    <button onclick="setCameraPreset(0)" id="preset-0">‚òÄÔ∏è Sun View</button>
                    <button onclick="setCameraPreset(1)" id="preset-1">‚ôÇ Mars View</button>
                    <button onclick="setCameraPreset(2)" id="preset-2">üåç Earth Close</button>
                    <button onclick="setCameraPreset(3)" id="preset-3">üåô Moon View</button>
                    <button onclick="setCameraPreset(4)" id="preset-4">üõ∞Ô∏è Orbital</button>
                    <button onclick="setCameraPreset(5)" id="preset-5">‚ôÉ Jupiter</button>
                    <button onclick="setCameraPreset(6)" id="preset-6">üåå Solar System</button>
                    <button onclick="setCameraPreset(7)" id="preset-7">üß≠ Polar</button>
                    <button onclick="setCameraPreset(8)" id="preset-8">üé≤ Random Sat</button>
                </div>
                <button onclick="toggleFreeMode()" id="free-mode-btn">üéÆ FREE MODE</button>
                <button onclick="toggleFollowEarth()" id="follow-earth-btn">üåç FOLLOW EARTH</button>
                <button onclick="toggleNegativeLighting()" id="negative-btn">üåë NEGATIVE</button>
                <div style="font-size: 9px; margin-top: 5px; color: #888888;">Follow Earth: Camera tracks Earth's orbit<br>Works with Free Mode for manual control</div>
            </div>
            
            <!-- Object Following Section -->
            <div class="sidebar-section">
                <h3>üéØ Object Following</h3>
                <div style="font-size: 9px; margin-bottom: 8px; color: #888888;">Lock camera to object's orbit but look around freely</div>
                <div id="follow-objects">
                    <button onclick="followObject('sun')" id="follow-sun">‚òÄÔ∏è Sun</button>
                    <button onclick="followObject('mercury')" id="follow-mercury">‚òø Mercury</button>
                    <button onclick="followObject('venus')" id="follow-venus">‚ôÄ Venus</button>
                    <button onclick="followObject('earth')" id="follow-earth-orbit">üåç Earth</button>
                    <button onclick="followObject('mars')" id="follow-mars">‚ôÇ Mars</button>
                    <button onclick="followObject('jupiter')" id="follow-jupiter">‚ôÉ Jupiter</button>
                    <button onclick="followObject('saturn')" id="follow-saturn">‚ôÑ Saturn</button>
                    <button onclick="followObject('uranus')" id="follow-uranus">‚õ¢ Uranus</button>
                    <button onclick="followObject('neptune')" id="follow-neptune">‚ôÜ Neptune</button>
                    <button onclick="stopFollowing()" id="stop-follow">‚ùå Stop</button>
                </div>
                <div id="follow-status" style="font-size: 9px; margin-top: 5px; color: #888888;">Following: None</div>
            </div>
            
            <!-- Simulation Controls Section -->
            <div class="sidebar-section">
                <h3>‚öôÔ∏è Simulation Controls</h3>
        <button onclick="togglePause()">‚è∏Ô∏è PAUSE</button>
        <button onclick="resetSimulation()">üîÑ RESET</button>
        <button onclick="randomFailure()">‚ö†Ô∏è RANDOM FAILURE</button><br>
        <button onclick="toggleOrbits()">üåç ORBITS</button>
        <button onclick="toggleTrails()">‚ú® TRAILS</button><br>
        <div class="config-row">
            <label>Speed:</label>
            <input type="range" id="simulation-speed" min="0.1" max="3" step="0.1" value="1" oninput="updateSimulationSpeed()">
            <span id="speed-display">1.0x</span>
        </div>
    </div>
    
            <!-- Satellite Configuration Section -->
            <div class="sidebar-section">
                <h3>üõ∞Ô∏è Satellite Configuration</h3>
        <div style="font-size: 9px; margin-bottom: 8px; color: #888888;">Click & hold labels to highlight satellites</div>
        <div class="config-row">
            <label class="satellite-class-label" data-type="LEO_COMM" onmousedown="highlightSatelliteClass('LEO_COMM')" onmouseup="unhighlightAllSatellites()" onmouseleave="unhighlightAllSatellites()" ontouchstart="highlightSatelliteClass('LEO_COMM')" ontouchend="unhighlightAllSatellites()">LEO Comm:</label>
            <input type="range" id="leo-comm" value="50" min="0" max="6768" step="10">
            <span id="leo-comm-value" class="slider-value">50</span>
        </div>
        <div class="config-row">
            <label class="satellite-class-label" data-type="LEO_WEATHER" onmousedown="highlightSatelliteClass('LEO_WEATHER')" onmouseup="unhighlightAllSatellites()" onmouseleave="unhighlightAllSatellites()" ontouchstart="highlightSatelliteClass('LEO_WEATHER')" ontouchend="unhighlightAllSatellites()">Weather:</label>
            <input type="range" id="weather" value="25" min="0" max="1000" step="5">
            <span id="weather-value" class="slider-value">25</span>
        </div>
        <div class="config-row">
            <label class="satellite-class-label" data-type="MEO_NAV" onmousedown="highlightSatelliteClass('MEO_NAV')" onmouseup="unhighlightAllSatellites()" onmouseleave="unhighlightAllSatellites()" ontouchstart="highlightSatelliteClass('MEO_NAV')" ontouchend="unhighlightAllSatellites()">GPS/Nav:</label>
            <input type="range" id="nav" value="32" min="0" max="143" step="1">
            <span id="nav-value" class="slider-value">32</span>
        </div>
        <div class="config-row">
            <label class="satellite-class-label" data-type="GEO_COMM" onmousedown="highlightSatelliteClass('GEO_COMM')" onmouseup="unhighlightAllSatellites()" onmouseleave="unhighlightAllSatellites()" ontouchstart="highlightSatelliteClass('GEO_COMM')" ontouchend="unhighlightAllSatellites()">GEO Comm:</label>
            <input type="range" id="geo-comm" value="30" min="0" max="590" step="5">
            <span id="geo-comm-value" class="slider-value">30</span>
        </div>
        <div class="config-row">
            <label class="satellite-class-label" data-type="MILITARY" onmousedown="highlightSatelliteClass('MILITARY')" onmouseup="unhighlightAllSatellites()" onmouseleave="unhighlightAllSatellites()" ontouchstart="highlightSatelliteClass('MILITARY')" ontouchend="unhighlightAllSatellites()">Military:</label>
            <input type="range" id="military" value="22" min="0" max="59" step="1">
            <span id="military-value" class="slider-value">22</span>
        </div>
        <div class="config-row">
            <label>Trail Length:</label>
            <input type="number" id="trail-length" value="50" min="10" max="200">
        </div>
        <button onclick="applySatelliteConfig()">APPLY CONFIG</button>
    </div>
    

            <!-- Navigation Help Section -->
            <div class="sidebar-section">
                <h3>üß≠ Navigation</h3>
                <div><strong>Global Mode:</strong></div>
                <div>‚Ä¢ Drag: Spin Solar System</div>
                <div>‚Ä¢ Wheel: Zoom In/Out</div>
                <div>‚Ä¢ Click: Select Satellite</div>
                <div><strong>Free Mode:</strong></div>
        <div>‚Ä¢ Drag: Look Around</div>
        <div>‚Ä¢ WASD: Move Camera</div>
        <div>‚Ä¢ Q/E: Up/Down</div>
        <div>‚Ä¢ Shift: Fast Mode</div>
        <div>‚Ä¢ Space: Reset View</div>
                <div><strong>Touch:</strong></div>
                <div>‚Ä¢ Drag: Rotate View</div>
                <div>‚Ä¢ Pinch: Zoom</div>
                <div>‚Ä¢ Tap: Select</div>
            </div>
            
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, earth, moon, sun, sunLight, earthSystem, satellites = [], orbitalRings = [], trails = [];
        let paused = false, showOrbits = true, showTrails = false, autoCamera = false;
        let selectedSatellite = null;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let cameraControls = { 
            forward: false, backward: false, left: false, right: false, 
            up: false, down: false, fast: false 
        };
        let maxTrailLength = 50;
        let cameraRotation = { x: 0, y: 0 };
        let mousePressed = false;
        let simulationSpeed = 1.0;
        let earthOrbitAngle = 0;
        let moonOrbitAngle = 0;
        let highlightedSatellites = [];
        let currentCameraPreset = 2;
        let freeMode = false;
        let followEarth = false;
        let uiVisible = true;
        let earthFollowOffset = new THREE.Vector3();
        let lastEarthPosition = new THREE.Vector3();
        let negativeLighting = false;
        let followingObject = null;
        let followingObjectName = '';
        let lastFollowedPosition = new THREE.Vector3();
        let followOffset = new THREE.Vector3(5, 2, 5);
        let planets = {};
        let planetAngles = {};
        let planetMoons = {};
        let moonAngles = {};
        let planetOrbits = [];
        let moonOrbits = [];
        let voyagerCrafts = [];
        
        // Global camera control variables
        let globalCameraDistance = 200;
        let globalCameraAngleX = 0;
        let globalCameraAngleY = 0;
        let globalCameraTarget = new THREE.Vector3(0, 0, 0);
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // Enhanced planet data with moons (scaled for visualization)
        const planetData = {
            mercury: { 
                name: "Mercury", size: 0.15, distance: 20, speed: 0.001, color: 0x8c7853, tilt: 0.034,
                moons: []
            },
            venus: { 
                name: "Venus", size: 0.36, distance: 30, speed: 0.0007, color: 0xffc649, tilt: 177.4,
                moons: []
            },
            earth: {
                name: "Earth", size: 1, distance: 50, speed: 0.0002, color: 0x6b93d6, tilt: 23.44,
                moons: [
                    { name: "Moon", size: 0.27, distance: 15, speed: 0.002, color: 0xaaaaaa }
                ]
            },
            mars: { 
                name: "Mars", size: 0.2, distance: 70, speed: 0.0003, color: 0xcd5c5c, tilt: 25.19,
                moons: [
                    { name: "Phobos", size: 0.008, distance: 0.6, speed: 0.02, color: 0x8c7853 },
                    { name: "Deimos", size: 0.006, distance: 1.0, speed: 0.01, color: 0x8c7853 }
                ]
            },
            jupiter: { 
                name: "Jupiter", size: 4.2, distance: 120, speed: 0.00008, color: 0xd8ca9d, tilt: 3.13,
                moons: [
                    { name: "Io", size: 0.12, distance: 7, speed: 0.008, color: 0xffff99 },
                    { name: "Europa", size: 0.10, distance: 9, speed: 0.006, color: 0xaaeeff },
                    { name: "Ganymede", size: 0.18, distance: 12, speed: 0.004, color: 0x888888 },
                    { name: "Callisto", size: 0.16, distance: 16, speed: 0.003, color: 0x444444 }
                ]
            },
            saturn: { 
                name: "Saturn", size: 3.5, distance: 180, speed: 0.00005, color: 0xfad5a5, tilt: 26.73,
                moons: [
                    { name: "Mimas", size: 0.04, distance: 6, speed: 0.009, color: 0xcccccc },
                    { name: "Enceladus", size: 0.05, distance: 8, speed: 0.007, color: 0xffffff },
                    { name: "Titan", size: 0.25, distance: 15, speed: 0.003, color: 0xffaa44 },
                    { name: "Iapetus", size: 0.08, distance: 22, speed: 0.002, color: 0x666666 }
                ]
            },
            uranus: { 
                name: "Uranus", size: 1.5, distance: 240, speed: 0.00003, color: 0x4fd0e3, tilt: 97.77,
                moons: [
                    { name: "Miranda", size: 0.04, distance: 3, speed: 0.012, color: 0xaaaaaa },
                    { name: "Ariel", size: 0.06, distance: 4, speed: 0.009, color: 0xbbbbbb },
                    { name: "Umbriel", size: 0.06, distance: 5, speed: 0.007, color: 0x777777 },
                    { name: "Titania", size: 0.08, distance: 7, speed: 0.005, color: 0x999999 },
                    { name: "Oberon", size: 0.08, distance: 9, speed: 0.004, color: 0x888888 }
                ]
            },
            neptune: { 
                name: "Neptune", size: 1.4, distance: 300, speed: 0.00002, color: 0x4b70dd, tilt: 28.32,
                moons: [
                    { name: "Triton", size: 0.12, distance: 6, speed: 0.008, color: 0xdddddd },
                    { name: "Nereid", size: 0.03, distance: 20, speed: 0.001, color: 0xaaaaaa }
                ]
            }
        };
        
        // Voyager mission data
        const voyagerData = {
            voyager1: {
                name: "Voyager 1",
                launchDate: "1977-09-05",
                currentDistance: 159, // AU from Sun (approximate)
                status: "Active",
                mission: "Grand Tour of outer planets",
                achievements: [
                    "First spacecraft to cross heliopause",
                    "Discovered active volcanism on Io",
                    "Detailed images of Jupiter and Saturn systems"
                ]
            },
            voyager2: {
                name: "Voyager 2", 
                launchDate: "1977-08-20",
                currentDistance: 132, // AU from Sun (approximate)
                status: "Active",
                mission: "Grand Tour of all outer planets",
                achievements: [
                    "Only spacecraft to visit Uranus and Neptune",
                    "Discovered 11 new moons around Uranus",
                    "Found 6 new moons around Neptune"
                ]
            }
        };
        
        // Camera presets - predefined advantageous viewing positions
        const cameraPresets = [
            {
                name: "Sun View",
                description: "From Sun looking at Earth",
                getPosition: () => {
                    const sunPos = sun.position.clone();
                    const earthPos = earthSystem.position.clone();
                    const direction = earthPos.clone().sub(sunPos).normalize();
                    return sunPos.clone().add(direction.multiplyScalar(8));
                },
                getTarget: () => earthSystem.position.clone()
            },
            {
                name: "Mars View",
                description: "View Earth from Mars",
                getPosition: () => {
                    const mars = planets.mars;
                    if (mars) {
                        const marsPos = mars.position.clone();
                    const earthPos = earthSystem.position.clone();
                        // Position camera slightly off Mars towards Earth
                        const marsToEarth = earthPos.clone().sub(marsPos).normalize();
                        return marsPos.clone().add(marsToEarth.multiplyScalar(2));
                    } else {
                        // Fallback if Mars not available
                        const earthPos = earthSystem.position.clone();
                        return earthPos.clone().add(new THREE.Vector3(40, 10, 20));
                    }
                },
                getTarget: () => earthSystem.position.clone()
            },
            {
                name: "Earth Close",
                description: "Close orbit around Earth",
                getPosition: () => {
                    const earthPos = earthSystem.position.clone();
                    const sunPos = sun.position.clone();
                    // Position camera between Sun and Earth, but closer to Earth
                    const sunToEarth = earthPos.clone().sub(sunPos).normalize();
                    const offset = sunToEarth.clone().multiplyScalar(-8); // Negative to be on Sun side
                    return earthPos.clone().add(offset).add(new THREE.Vector3(0, 3, 2));
                },
                getTarget: () => earthSystem.position.clone()
            },
            {
                name: "Moon View",
                description: "From Moon looking at Earth",
                getPosition: () => {
                    const moonWorldPos = new THREE.Vector3();
                    moon.getWorldPosition(moonWorldPos);
                    return moonWorldPos.clone();
                },
                getTarget: () => earthSystem.position.clone()
            },
            {
                name: "Orbital View",
                description: "Satellite constellation overview",
                getPosition: () => {
                    const earthPos = earthSystem.position.clone();
                    const sunPos = sun.position.clone();
                    // Position camera for satellite overview, showing illuminated side
                    const sunToEarth = earthPos.clone().sub(sunPos).normalize();
                    const offset = sunToEarth.clone().multiplyScalar(-15); // On Sun side
                    return earthPos.clone().add(offset).add(new THREE.Vector3(0, 10, 5));
                },
                getTarget: () => earthSystem.position.clone()
            },
            {
                name: "Jupiter View",
                description: "View Jupiter and outer planets",
                getPosition: () => {
                    const jupiter = planets.jupiter;
                    if (jupiter) {
                        const jupiterPos = jupiter.position.clone();
                        const sunPos = sun.position.clone();
                        // Position camera to show Jupiter from sunlit side
                        const sunToJupiter = jupiterPos.clone().sub(sunPos).normalize();
                        const offset = sunToJupiter.clone().multiplyScalar(-25); // Distance from Jupiter
                        return jupiterPos.clone().add(offset).add(new THREE.Vector3(0, 15, 10));
                    } else {
                        return new THREE.Vector3(100, 30, 80);
                    }
                },
                getTarget: () => {
                    const jupiter = planets.jupiter;
                    return jupiter ? jupiter.position.clone() : new THREE.Vector3(120, 0, 0);
                }
            },
            {
                name: "Solar System",
                description: "Wide view of entire solar system",
                getPosition: () => new THREE.Vector3(200, 100, 300),
                getTarget: () => new THREE.Vector3(0, 0, 0)
            },
            {
                name: "Earth Polar",
                description: "View from Earth's pole",
                getPosition: () => {
                    const earthPos = earthSystem.position.clone();
                    const sunPos = sun.position.clone();
                    // Position camera above Earth's pole, slightly towards Sun
                    const sunToEarth = earthPos.clone().sub(sunPos).normalize();
                    const offset = sunToEarth.clone().multiplyScalar(-3); // Slight offset towards Sun
                    return earthPos.clone().add(new THREE.Vector3(0, 20, 0)).add(offset);
                },
                getTarget: () => earthSystem.position.clone()
            },
            {
                name: "Random Satellite",
                description: "Random satellite perspective",
                getPosition: () => {
                    const activeSatellites = satellites.filter(s => s.userData.status === 'operational');
                    if (activeSatellites.length === 0) {
                        const earthPos = earthSystem.position.clone();
                        return earthPos.clone().add(new THREE.Vector3(8, 3, 8));
                    }
                    const randomSat = activeSatellites[Math.floor(Math.random() * activeSatellites.length)];
                    const satWorldPos = new THREE.Vector3();
                    randomSat.getWorldPosition(satWorldPos);
                    return satWorldPos.clone().add(new THREE.Vector3(0.5, 0.3, 0.5));
                },
                getTarget: () => earthSystem.position.clone()
            }
        ];
        
        // Touch controls
        let touchStart = { x: 0, y: 0 };
        let touchCurrent = { x: 0, y: 0 };
        let isTouching = false;
        let touchCount = 0;
        let initialPinchDistance = 0;
        let currentPinchDistance = 0;
        
        // Satellite classes with realistic orbital parameters and inclinations
        // Earth radius = 1 unit, so distances are in Earth radii from center
        const satelliteClasses = {
            LEO_COMM: { 
                altitude: 1.15, // ~400km altitude (1 + 400/6371)
                color: 0x3333ff, 
                name: "LEO Communications", 
                speed: 0.02,
                inclinations: [0, 15, 30, 45, 60, 75, 90, 105]
            },
            LEO_WEATHER: { 
                altitude: 1.25, // ~800km altitude 
                color: 0x33ffff, 
                name: "Weather Satellite", 
                speed: 0.018,
                inclinations: [90, 105, 98, 85]
            },
            MEO_NAV: { 
                altitude: 4.2, // ~20,200km altitude (GPS orbit)
                color: 0xffff33, 
                name: "Navigation (GPS)", 
                speed: 0.008,
                inclinations: [55, 55, 55, 55, 55, 55]
            },
            GEO_COMM: { 
                altitude: 6.6, // ~35,786km altitude (geostationary)
                color: 0x3333ff, 
                name: "GEO Communications", 
                speed: 0.002, // Same as Earth rotation
                inclinations: [0, 2, 1]
            },
            MILITARY: { 
                altitude: 1.4, // ~1000km altitude
                color: 0xff33ff, 
                name: "Military/Recon", 
                speed: 0.015,
                inclinations: [28, 45, 63, 82, 97]
            }
        };
        
        // Object Following Functions
        function followObject(objectName) {
            // Reset any existing follow modes
            followEarth = false;
            
            // Set new following object
            followingObjectName = objectName;
            followingObject = true;
            
            // Get initial position
            const initialPosition = new THREE.Vector3();
            if (objectName === 'sun') {
                initialPosition.copy(sun.position);
            } else if (objectName === 'earth') {
                initialPosition.copy(earthSystem.position);
            } else if (planets[objectName]) {
                initialPosition.copy(planets[objectName].position);
            }
            
            // Calculate camera position on the sunlit side
            const sunPosition = sun.position.clone();
            let offsetPosition;
            
            if (objectName === 'sun') {
                // For sun, position camera at a distance
                offsetPosition = new THREE.Vector3(15, 8, 15);
            } else {
                // For other objects, position camera on the sunlit side (between sun and object)
                const objectToSun = sunPosition.clone().sub(initialPosition).normalize();
                
                // Calculate appropriate distance based on object type
                let distance = 8; // Default distance
                if (objectName === 'earth') {
                    distance = 10;
                } else if (['jupiter', 'saturn'].includes(objectName)) {
                    distance = 15;
                } else if (['mercury', 'venus'].includes(objectName)) {
                    distance = 6;
                } else if (['mars'].includes(objectName)) {
                    distance = 8;
                } else if (['uranus', 'neptune'].includes(objectName)) {
                    distance = 12;
                }
                
                // Position camera between object and sun, closer to object but on sunlit side
                // This ensures we see the illuminated face of the object
                const sunDirection = objectToSun.clone(); // Direction from object towards sun
                const lateralOffset = new THREE.Vector3(-sunDirection.z, 0, sunDirection.x).normalize().multiplyScalar(distance * 0.3);
                const verticalOffset = new THREE.Vector3(0, distance * 0.3, 0);
                
                offsetPosition = initialPosition.clone()
                    .add(sunDirection.multiplyScalar(distance * 0.6)) // Move towards sun from object
                    .add(lateralOffset) // Add lateral offset for better angle
                    .add(verticalOffset); // Add some height
            }
            
            camera.position.copy(offsetPosition);
            camera.lookAt(initialPosition); // Always look at the object
            
            // Initialize last position tracking
            lastFollowedPosition.copy(initialPosition);
            
            // Enable free mode for look-around capability
            freeMode = true;
            
            // Update UI
            updateFollowButtons();
            updateFreeModeButton();
            updateFollowEarthButton();
            updateCameraInfo();
            
            console.log(`Now following: ${objectName} from sunlit side`);
        }
        
        function stopFollowing() {
            followingObject = false;
            followingObjectName = '';
            followEarth = false;
            
            // Reset to preset mode
            freeMode = false;
            setCameraPreset(5); // Solar system view
            
            // Update UI
            updateFollowButtons();
            updateFreeModeButton();
            updateFollowEarthButton();
            updateCameraInfo();
            
            console.log('Stopped following objects');
        }
        
        function updateFollowButtons() {
            const buttons = document.querySelectorAll('#follow-objects button');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            if (followingObjectName) {
                const activeBtn = document.getElementById(`follow-${followingObjectName}`);
                if (activeBtn) {
                    activeBtn.classList.add('active');
                }
            }
            
            // Update status text
            const statusEl = document.getElementById('follow-status');
            if (statusEl) {
                statusEl.textContent = followingObjectName ? 
                    `Following: ${followingObjectName.charAt(0).toUpperCase() + followingObjectName.slice(1)}` : 
                    'Following: None';
            }
        }
        
        // Initialize the simulation
        function init() {
            try {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                // Will be set to Sun view after solar system is created
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.body.appendChild(renderer.domElement);
                
                // Create solar system
                createSun();
                createPlanets();
                createEarthSystem();
                
                // Create orbital rings
                createOrbitalRings();
                
                // Create satellites
                createSatellites();
                
                // Create stars
                createStars();
                
                // Add lighting
                const ambientLight = new THREE.AmbientLight(0x202040, 0.2);
                scene.add(ambientLight);
                
                // Set default camera to Earth Close view
                setCameraPreset(2);
                
                // Initialize Earth tracking
                lastEarthPosition.copy(earthSystem.position);
                
                // Initialize UI button states
                updatePresetButtons();
                updateFreeModeButton();
                updateFollowEarthButton();
                updateNegativeButton();
                updateFollowButtons();
                
                // Add event listeners
                window.addEventListener('resize', onWindowResize);
                renderer.domElement.addEventListener('click', onMouseClick);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('mousedown', onMouseDown);
                renderer.domElement.addEventListener('mouseup', onMouseUp);
                renderer.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);
                
                // Touch event listeners
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                
                // Disable context menu
                renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
                
                // Start animation
                animate();
                
                console.log('Simulation initialized successfully');
            } catch (error) {
                console.error('Error initializing simulation:', error);
            }
        }
        
        function createSun() {
            // Create Sun group for all flame layers
            sun = new THREE.Group();
            sun.position.set(0, 0, 0);
            scene.add(sun);
            
            // Create main sun core
            const coreGeometry = new THREE.SphereGeometry(2.5, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: false
            });
            const sunCore = new THREE.Mesh(coreGeometry, coreMaterial);
            sun.add(sunCore);
            
            // Create multiple flame layers with different sizes and colors
            window.sunFlames = [];
            const flameCount = 5;
            const colors = [0xff4400, 0xff6600, 0xff8800, 0xffaa00, 0xffcc00];
            const sizes = [3.0, 3.3, 3.6, 3.9, 4.2];
            const opacities = [0.4, 0.3, 0.25, 0.2, 0.15];
            
            for (let i = 0; i < flameCount; i++) {
                const flameGeometry = new THREE.SphereGeometry(sizes[i], 16, 16);
                const flameMaterial = new THREE.MeshBasicMaterial({
                    color: colors[i],
                    transparent: true,
                    opacity: opacities[i],
                    blending: THREE.AdditiveBlending
                });
                
                const flame = new THREE.Mesh(flameGeometry, flameMaterial);
                flame.userData = {
                    originalScale: 1,
                    animationOffset: Math.random() * Math.PI * 2,
                    animationSpeed: 0.2 + Math.random() * 0.3
                };
                
                sun.add(flame);
                window.sunFlames.push(flame);
            }
            
            // Add outer glow effect
            const glowGeometry = new THREE.SphereGeometry(5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                transparent: true,
                opacity: 0.1,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide
            });
            const sunGlow = new THREE.Mesh(glowGeometry, glowMaterial);
            sun.add(sunGlow);
            
            // Create sun light that will point toward Earth
            sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
            sunLight.position.set(0, 0, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -50;
            sunLight.shadow.camera.right = 50;
            sunLight.shadow.camera.top = 50;
            sunLight.shadow.camera.bottom = -50;
            scene.add(sunLight);
        }
        
        function createPlanets() {
            Object.keys(planetData).forEach(planetKey => {
                const data = planetData[planetKey];
                
                // Create planet orbit visualization
                const orbitGeometry = new THREE.RingGeometry(data.distance - 0.5, data.distance + 0.5, 128);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                planetOrbits.push(orbit);
                scene.add(orbit);
                
                // Create planet geometry
                const planetGeometry = new THREE.SphereGeometry(data.size, 32, 32);
                
                // Create textured material
                const planetMaterial = new THREE.MeshPhongMaterial({
                    color: data.color,
                    shininess: 10,
                    transparent: false,
                    emissive: new THREE.Color(data.color).multiplyScalar(0.05) // Slight self-illumination
                });
                
                // Create planet group to hold planet and moons
                const planetGroup = new THREE.Group();
                
                // Add some texture variation
                if (planetKey === 'jupiter') {
                    // Jupiter stripes effect
                    planetMaterial.bumpScale = 0.05;
                } else if (planetKey === 'saturn') {
                    // Saturn rings
                    const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                    
                    // Create rings
                    const ringGeometry = new THREE.RingGeometry(data.size * 1.2, data.size * 2.2, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffddaa,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });
                    const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                    rings.rotation.x = Math.PI / 2;
                    
                    planetGroup.add(planet);
                    planetGroup.add(rings);
                    
                    // Apply axial tilt
                    planetGroup.rotation.z = (data.tilt * Math.PI) / 180;
                } else {
                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.receiveShadow = true;
                planet.castShadow = true;
                
                // Apply axial tilt
                planet.rotation.z = (data.tilt * Math.PI) / 180;
                
                    planetGroup.add(planet);
                }
                
                // Create moons for this planet
                if (data.moons && data.moons.length > 0) {
                    const planetMoonGroup = [];
                    const planetMoonAngles = [];
                    
                    data.moons.forEach((moonData, index) => {
                        // Create moon orbit
                        const moonOrbitGeometry = new THREE.RingGeometry(moonData.distance - 0.05, moonData.distance + 0.05, 64);
                        const moonOrbitMaterial = new THREE.MeshBasicMaterial({
                            color: moonData.color,
                            transparent: true,
                            opacity: 0.15,
                            side: THREE.DoubleSide
                        });
                        const moonOrbit = new THREE.Mesh(moonOrbitGeometry, moonOrbitMaterial);
                        moonOrbit.rotation.x = Math.PI / 2;
                        planetGroup.add(moonOrbit);
                        moonOrbits.push(moonOrbit);
                        
                        // Create moon
                        const moonGeometry = new THREE.SphereGeometry(moonData.size, 16, 16);
                        const moonMaterial = new THREE.MeshPhongMaterial({
                            color: moonData.color,
                            shininess: 5
                        });
                        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
                        
                        // Position moon
                        const angle = Math.random() * Math.PI * 2;
                        moon.position.x = Math.cos(angle) * moonData.distance;
                        moon.position.z = Math.sin(angle) * moonData.distance;
                        
                        moon.receiveShadow = true;
                        moon.castShadow = true;
                        
                        planetGroup.add(moon);
                        planetMoonGroup.push(moon);
                        planetMoonAngles.push(angle);
                    });
                    
                    planetMoons[planetKey] = planetMoonGroup;
                    moonAngles[planetKey] = planetMoonAngles;
                }
                
                // Position planet group
                planetGroup.position.x = data.distance;
                planetGroup.receiveShadow = true;
                planetGroup.castShadow = true;
                
                planets[planetKey] = planetGroup;
                planetAngles[planetKey] = Math.random() * Math.PI * 2; // Random starting position
                scene.add(planetGroup);
            });
        }
        
        function createEarthSystem() {
            // Create Earth system group
            earthSystem = new THREE.Group();
            earthSystem.position.set(50, 0, 0); // Initial distance from Sun
            scene.add(earthSystem);
            
            // Create Earth
            const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
            
            // Load Earth texture
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load(
                './img/earth-texture.jpg',
                function(texture) {
                    console.log('Earth texture loaded successfully');
                },
                function(progress) {
                    console.log('Loading earth texture:', (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.log('Error loading earth texture, using fallback color');
                }
            );
            
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: earthTexture,
                color: 0xffffff
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earth.receiveShadow = true;
            earth.castShadow = true;
            earthSystem.add(earth);
            
            // Add atmosphere glow
            const atmosphereGeometry = new THREE.SphereGeometry(1.05, 32, 32);
            const atmosphereMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            earthSystem.add(atmosphere);
            
            // Create Moon (realistic distance - about 60 Earth radii, scaled down to 15 for visibility)
            const moonGeometry = new THREE.SphereGeometry(0.27, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaaa
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(15, 0, 0); // More realistic distance from Earth (was 3.8)
            moon.receiveShadow = true;
            moon.castShadow = true;
            earthSystem.add(moon);
            
            // Add Earth to planets for orbital mechanics
            planets.earth = earthSystem;
            planetAngles.earth = 0; // Start at 0 angle
            
            // Create Earth's orbital path
            const earthOrbitGeometry = new THREE.RingGeometry(49.8, 50.2, 128);
            const earthOrbitMaterial = new THREE.MeshBasicMaterial({
                color: 0x6b93d6,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const earthOrbit = new THREE.Mesh(earthOrbitGeometry, earthOrbitMaterial);
            earthOrbit.rotation.x = Math.PI / 2;
            scene.add(earthOrbit);
            planetOrbits.push(earthOrbit);
        }
        
        function createOrbitalRings() {
            // Clear existing rings
            orbitalRings.forEach(ring => scene.remove(ring));
            orbitalRings = [];
            
            Object.values(satelliteClasses).forEach(satClass => {
                satClass.inclinations.forEach((inclination, index) => {
                    const ringGeometry = new THREE.RingGeometry(satClass.altitude - 0.02, satClass.altitude + 0.02, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: satClass.color,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Apply inclination
                    ring.rotation.x = (inclination * Math.PI) / 180;
                    ring.rotation.z = (index * 30 * Math.PI) / 180;
                    
                    orbitalRings.push(ring);
                    earthSystem.add(ring);
                });
            });
        }
        
        function createSatellites() {
            // Clear existing satellites and trails
            satellites.forEach(satellite => scene.remove(satellite));
            trails.forEach(trail => scene.remove(trail));
            satellites = [];
            trails = [];
            
            // Get counts from UI
            const counts = {
                LEO_COMM: parseInt(document.getElementById('leo-comm').value) || 0,
                LEO_WEATHER: parseInt(document.getElementById('weather').value) || 0,
                MEO_NAV: parseInt(document.getElementById('nav').value) || 0,
                GEO_COMM: parseInt(document.getElementById('geo-comm').value) || 0,
                MILITARY: parseInt(document.getElementById('military').value) || 0
            };
            
            maxTrailLength = parseInt(document.getElementById('trail-length').value) || 50;
            
            Object.entries(counts).forEach(([type, count]) => {
                for (let i = 0; i < count; i++) {
                    createSatellite(type, i, count);
                }
            });
            
            updateSatelliteCount();
        }
        
        function createSatellite(type, index, total) {
            const satClass = satelliteClasses[type];
            
            // Create satellite geometry
            const satelliteGroup = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.BoxGeometry(0.06, 0.04, 0.08);
            const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            satelliteGroup.add(body);
            
            // Solar panels
            const panelGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.08);
            const panelMaterial = new THREE.MeshPhongMaterial({ color: 0x000066 });
            const panel1 = new THREE.Mesh(panelGeometry, panelMaterial);
            panel1.position.x = 0.1;
            const panel2 = new THREE.Mesh(panelGeometry, panelMaterial);
            panel2.position.x = -0.1;
            satelliteGroup.add(panel1, panel2);
            
            // Antenna
            const antennaGeometry = new THREE.CylinderGeometry(0.005, 0.005, 0.08);
            const antennaMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.y = 0.06;
            satelliteGroup.add(antenna);
            
            // Position satellite in 3D orbit
            const angleStep = (Math.PI * 2) / (total || 1);
            const baseAngle = index * angleStep;
            const inclination = satClass.inclinations[index % satClass.inclinations.length];
            const ascendingNode = (index * 60) % 360;
            
            const orbitRadius = satClass.altitude;
            
            // Calculate initial position with inclination
            const pos = calculateOrbitalPosition(baseAngle, orbitRadius, inclination, ascendingNode);
            satelliteGroup.position.copy(pos);
            
            // Add status indicator light
            const lightGeometry = new THREE.SphereGeometry(0.01, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: satClass.color,
                transparent: true,
                opacity: 0.8
            });
            const statusLight = new THREE.Mesh(lightGeometry, lightMaterial);
            statusLight.position.y = 0.03;
            satelliteGroup.add(statusLight);
            
            // Create trail with BufferGeometry
            const trailGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(100 * 3); // 100 points max
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: satClass.color,
                transparent: true,
                opacity: 0.7
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            trail.visible = showTrails;
            trails.push(trail);
            scene.add(trail);
            
            console.log(`Trail created for ${type}_${index}, color: 0x${satClass.color.toString(16)}, visible: ${trail.visible}`);
            
            // Satellite properties
            satelliteGroup.userData = {
                type: type,
                class: satClass,
                angle: baseAngle,
                orbitRadius: orbitRadius,
                inclination: inclination,
                ascendingNode: ascendingNode,
                status: 'operational',
                id: `${type}_${index}`,
                health: 100,
                statusLight: statusLight,
                originalColor: satClass.color,
                trail: trail,
                trailPositions: []
            };
            
            satelliteGroup.castShadow = true;
            satellites.push(satelliteGroup);
            earthSystem.add(satelliteGroup);
        }
        
        function calculateOrbitalPosition(angle, radius, inclination, ascendingNode) {
            // Convert angles to radians
            const incRad = (inclination * Math.PI) / 180;
            const nodeRad = (ascendingNode * Math.PI) / 180;
            
            // Calculate position in orbital plane
            const x_orbit = Math.cos(angle) * radius;
            const y_orbit = Math.sin(angle) * radius * Math.cos(incRad);
            const z_orbit = Math.sin(angle) * radius * Math.sin(incRad);
            
            // Rotate by ascending node
            const x = x_orbit * Math.cos(nodeRad) - y_orbit * Math.sin(nodeRad);
            const y = x_orbit * Math.sin(nodeRad) + y_orbit * Math.cos(nodeRad);
            const z = z_orbit;
            
            return new THREE.Vector3(x, z, y);
        }
        
        function createVoyagerCrafts() {
            // Create Voyager 1 and 2 as simplified models
            Object.keys(voyagerData).forEach(voyagerKey => {
                const data = voyagerData[voyagerKey];
                
                // Create main body (simplified box)
                const bodyGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.15);
                const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Create dish antenna
                const dishGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16);
                const dishMaterial = new THREE.MeshPhongMaterial({ color: 0xdddddd });
                const dish = new THREE.Mesh(dishGeometry, dishMaterial);
                dish.position.set(0, 0.15, 0);
                
                // Create boom arms
                const boomGeometry = new THREE.CylinderGeometry(0.005, 0.005, 1, 8);
                const boomMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                
                const boom1 = new THREE.Mesh(boomGeometry, boomMaterial);
                boom1.rotation.z = Math.PI / 2;
                boom1.position.x = 0.5;
                
                const boom2 = new THREE.Mesh(boomGeometry, boomMaterial);
                boom2.rotation.z = -Math.PI / 2;
                boom2.position.x = -0.5;
                
                // RTG (Radioisotope Thermoelectric Generator)
                const rtgGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
                const rtgMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
                const rtg = new THREE.Mesh(rtgGeometry, rtgMaterial);
                rtg.position.set(0.8, 0, 0);
                
                // Instruments
                const instGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
                const instMaterial = new THREE.MeshPhongMaterial({ color: 0x555555 });
                const instruments = new THREE.Mesh(instGeometry, instMaterial);
                instruments.position.set(0, 0, 0.1);
                
                // Create Voyager group
                const voyager = new THREE.Group();
                voyager.add(body);
                voyager.add(dish);
                voyager.add(boom1);
                voyager.add(boom2);
                voyager.add(rtg);
                voyager.add(instruments);
                
                // Position Voyager at current approximate distance
                const angle = voyagerKey === 'voyager1' ? 0.5 : 1.0;
                const distance = data.currentDistance * 2; // Scale for visualization
                voyager.position.x = Math.cos(angle) * distance;
                voyager.position.z = Math.sin(angle) * distance;
                voyager.position.y = voyagerKey === 'voyager1' ? 20 : -15; // Different heights
                
                voyager.userData = {
                    name: data.name,
                    type: 'voyager',
                    data: data
                };
                
                // Create trajectory path for Voyager
                const trajectoryPoints = [];
                const numPoints = 100;
                const maxDistance = data.currentDistance * 2;
                
                for (let i = 0; i < numPoints; i++) {
                    const t = i / (numPoints - 1);
                    const currentDistance = 10 + t * (maxDistance - 10); // From 10 AU to current distance
                    const currentAngle = angle + t * 0.5; // Slight curve to trajectory
                    
                    trajectoryPoints.push(new THREE.Vector3(
                        Math.cos(currentAngle) * currentDistance,
                        voyagerKey === 'voyager1' ? 20 - t * 10 : -15 + t * 5,
                        Math.sin(currentAngle) * currentDistance
                    ));
                }
                
                const trajectoryGeometry = new THREE.BufferGeometry().setFromPoints(trajectoryPoints);
                const trajectoryMaterial = new THREE.LineBasicMaterial({
                    color: voyagerKey === 'voyager1' ? 0xffd700 : 0x87ceeb,
                    transparent: true,
                    opacity: 0.6
                });
                const trajectory = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
                trajectory.visible = showOrbits;
                scene.add(trajectory);
                planetOrbits.push(trajectory); // Add to planet orbits for visibility toggle
                
                voyagerCrafts.push(voyager);
                scene.add(voyager);
                
                console.log(`${data.name} created at distance ${data.currentDistance} AU`);
            });
        }
        
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                // Random positions
                positions[i * 3] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 400;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 400;
                
                // Random sizes for variety
                sizes[i] = Math.random() * 3 + 1;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Create glow texture for stars
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            // Create radial gradient for glow effect
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            
            const starTexture = new THREE.CanvasTexture(canvas);
            
            const starMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 2,
                transparent: true,
                opacity: 0.9,
                map: starTexture,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true,
                vertexColors: false
            });
            
            window.starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(window.starField);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (!paused) {
                // Animate sun flames
                if (window.sunFlames) {
                    const time = Date.now() * 0.001;
                    window.sunFlames.forEach((flame, index) => {
                        const animTime = time * flame.userData.animationSpeed + flame.userData.animationOffset;
                        const scale = 1 + Math.sin(animTime) * 0.03 + Math.cos(animTime * 1.3) * 0.02;
                        flame.scale.setScalar(scale);
                        
                        // Very subtle rotation for dynamic effect
                        flame.rotation.y += 0.003 * simulationSpeed;
                        flame.rotation.x += 0.002 * simulationSpeed;
                    });
                }
                
                // Rotate Earth on its axis
                earth.rotation.y += 0.005 * simulationSpeed;
                
                // Earth now orbits through the planet system
                // Orbit Moon around Earth
                moonOrbitAngle += 0.002 * simulationSpeed; // Slower orbit for realism
                moon.position.x = Math.cos(moonOrbitAngle) * 15;
                moon.position.z = Math.sin(moonOrbitAngle) * 15;
                
                // Animate planets
                Object.keys(planetData).forEach(planetKey => {
                    const data = planetData[planetKey];
                    const planet = planets[planetKey];
                    if (planet) {
                        // Update orbital position
                        planetAngles[planetKey] += data.speed * simulationSpeed;
                        planet.position.x = Math.cos(planetAngles[planetKey]) * data.distance;
                        planet.position.z = Math.sin(planetAngles[planetKey]) * data.distance;
                        
                        // Rotate planet on its axis
                        if (planetKey === 'saturn') {
                            // Saturn is a group, rotate the planet inside
                            planet.children[0].rotation.y += 0.01 * simulationSpeed;
                        } else if (planet.children.length > 0) {
                            // Find the main planet mesh and rotate it
                            const mainPlanet = planet.children.find(child => child.geometry && child.geometry.type === 'SphereGeometry' && child.geometry.parameters.radius === data.size);
                            if (mainPlanet) {
                                mainPlanet.rotation.y += 0.01 * simulationSpeed;
                            }
                        } else {
                            planet.rotation.y += 0.01 * simulationSpeed;
                        }
                        
                        // Animate moons if they exist
                        if (planetMoons[planetKey] && moonAngles[planetKey]) {
                            planetMoons[planetKey].forEach((moon, index) => {
                                const moonData = data.moons[index];
                                if (moonData) {
                                    moonAngles[planetKey][index] += moonData.speed * simulationSpeed;
                                    const angle = moonAngles[planetKey][index];
                                    moon.position.x = Math.cos(angle) * moonData.distance;
                                    moon.position.z = Math.sin(angle) * moonData.distance;
                                    
                                    // Rotate moon on its axis
                                    moon.rotation.y += 0.02 * simulationSpeed;
                                }
                            });
                        }
                    }
                });
                
                // Update sun light to always point at Earth
                const earthWorldPosition = new THREE.Vector3();
                earthSystem.getWorldPosition(earthWorldPosition);
                const sunPosition = sun.position;
                const lightDirection = earthWorldPosition.clone().sub(sunPosition).normalize();
                sunLight.position.copy(sunPosition);
                sunLight.target.position.copy(earthWorldPosition);
                sunLight.target.updateMatrixWorld();
                
                // Update satellites
                satellites.forEach((satellite, index) => {
                    if (satellite.userData.status === 'operational') {
                        // Update orbital position
                        satellite.userData.angle += satellite.userData.class.speed * simulationSpeed;
                        
                        const pos = calculateOrbitalPosition(
                            satellite.userData.angle,
                            satellite.userData.orbitRadius,
                            satellite.userData.inclination,
                            satellite.userData.ascendingNode
                        );
                        satellite.position.copy(pos);
                        
                        // Update trail
                        updateTrail(satellite);
                        
                        // Random failure check (very low probability)
                        if (Math.random() < 0.0003) {
                            failSatellite(satellite);
                        }
                    } else if (satellite.userData.status === 'failed') {
                        // Failed satellites drift slowly
                        satellite.userData.angle += satellite.userData.class.speed * 0.1 * simulationSpeed;
                        const pos = calculateOrbitalPosition(
                            satellite.userData.angle,
                            satellite.userData.orbitRadius,
                            satellite.userData.inclination,
                            satellite.userData.ascendingNode
                        );
                        satellite.position.copy(pos);
                        
                        // Add tumbling to failed satellites
                        satellite.rotation.x += 0.02;
                        satellite.rotation.z += 0.01;
                        
                        // Update trail for failed satellites too
                        updateTrail(satellite);
                    }
                });
                
                // Handle Follow Earth mode
                if (followEarth) {
                    const currentEarthPosition = earthSystem.position.clone();
                    const earthMovement = currentEarthPosition.clone().sub(lastEarthPosition);
                    
                    // Move camera by the same amount Earth moved
                    camera.position.add(earthMovement);
                    
                    // Update last Earth position
                    lastEarthPosition.copy(currentEarthPosition);
                }
                
                // Handle Object Following mode
                if (followingObject) {
                    const currentFollowedPosition = new THREE.Vector3();
                    
                    // Get current position of followed object
                    if (followingObjectName === 'sun') {
                        currentFollowedPosition.copy(sun.position);
                    } else if (followingObjectName === 'earth') {
                        currentFollowedPosition.copy(earthSystem.position);
                    } else if (planets[followingObjectName]) {
                        currentFollowedPosition.copy(planets[followingObjectName].position);
                    }
                    
                    // Recalculate optimal camera position relative to sun for proper lighting
                    const sunPosition = sun.position.clone();
                    let optimalCameraPosition;
                    
                    if (followingObjectName === 'sun') {
                        // For sun, maintain a fixed offset
                        optimalCameraPosition = new THREE.Vector3(15, 8, 15);
                    } else {
                        // For other objects, maintain position on sunlit side
                        const objectToSun = sunPosition.clone().sub(currentFollowedPosition).normalize();
                        
                        // Distance based on object type
                        let distance = 8;
                        if (followingObjectName === 'earth') {
                            distance = 10;
                        } else if (['jupiter', 'saturn'].includes(followingObjectName)) {
                            distance = 15;
                        } else if (['mercury', 'venus'].includes(followingObjectName)) {
                            distance = 6;
                        } else if (['mars'].includes(followingObjectName)) {
                            distance = 8;
                        } else if (['uranus', 'neptune'].includes(followingObjectName)) {
                            distance = 12;
                        }
                        
                        // Calculate position on sunlit side - between object and sun, closer to object
                        const sunDirection = objectToSun.clone(); // Direction from object towards sun
                        const lateralOffset = new THREE.Vector3(-sunDirection.z, 0, sunDirection.x).normalize().multiplyScalar(distance * 0.3);
                        const verticalOffset = new THREE.Vector3(0, distance * 0.3, 0);
                        
                        optimalCameraPosition = currentFollowedPosition.clone()
                            .add(sunDirection.multiplyScalar(distance * 0.6)) // Move towards sun from object
                            .add(lateralOffset)
                            .add(verticalOffset);
                    }
                    
                    // Smoothly interpolate camera to optimal position
                    camera.position.lerp(optimalCameraPosition, 0.1);
                    
                    // Always look at the followed object in free mode
                    if (!freeMode) {
                        camera.lookAt(currentFollowedPosition);
                    }
                    
                    // Update last followed position
                    lastFollowedPosition.copy(currentFollowedPosition);
                }
                
                // Handle camera modes
                if (!freeMode) {
                    // Update camera based on current preset (only if not following Earth)
                    if (!followEarth) {
                        const preset = cameraPresets[currentCameraPreset];
                        if (preset) {
                            const newPos = preset.getPosition();
                            const newTarget = preset.getTarget();
                            
                            // For moon view and satellite view, update more frequently
                            if (currentCameraPreset === 3 || currentCameraPreset === 7) { // Moon or Random Satellite
                                camera.position.copy(newPos);
                                camera.lookAt(newTarget);
                } else {
                                // Smooth transition to preset position
                                camera.position.lerp(newPos, 0.02);
                                camera.lookAt(newTarget);
                            }
                        }
                    } else {
                        // In follow Earth mode, look at Earth
                        camera.lookAt(earthSystem.position);
                    }
                } else {
                    // Free mode - manual camera controls
                    updateCameraControls();
                    
                    // Even in free mode, if following Earth, look at Earth after manual movement
                    if (followEarth) {
                        camera.lookAt(earthSystem.position);
                }
                }
                
                updateCameraInfo();
            }
            
            renderer.render(scene, camera);
        }
        
        function updateCameraInfo() {
            const cameraInfoEl = document.getElementById('camera-info');
            const cameraModeEl = document.getElementById('camera-mode');
            
            if (followingObject) {
                const distance = camera.position.length();
                cameraInfoEl.textContent = `Camera: Following ${followingObjectName.charAt(0).toUpperCase() + followingObjectName.slice(1)}`;
                cameraModeEl.textContent = `Mode: Follow + Free Look | Distance: ${distance.toFixed(1)}`;
            } else if (freeMode) {
                const distance = camera.position.length();
                cameraInfoEl.textContent = `Camera: Manual (${distance.toFixed(1)}km)`;
                cameraModeEl.textContent = `Mode: Free | Follow: ${followEarth ? 'Earth' : 'Off'}`;
            } else {
                const preset = cameraPresets[currentCameraPreset];
                cameraInfoEl.textContent = `Camera: ${preset ? preset.name : 'Unknown'}`;
                cameraModeEl.textContent = `Mode: Preset | Follow: ${followEarth ? 'Earth' : 'Off'}`;
            }
        }
        
        function updateTrail(satellite) {
            const trail = satellite.userData.trail;
            if (!trail) return;
            
            // Set visibility based on global setting
            trail.visible = showTrails;
            
            // Initialize trail positions if needed
            if (!satellite.userData.trailPositions) {
                satellite.userData.trailPositions = [];
            }
            
            // Always collect positions for active trails (even when not visible)
            if (showTrails) {
                // Get current world position
            const worldPos = new THREE.Vector3();
            satellite.getWorldPosition(worldPos);
            
                // Add position to trail array
                const positions = satellite.userData.trailPositions;
            positions.push(worldPos.x, worldPos.y, worldPos.z);
            
                // Keep trail length manageable
                if (positions.length > 150) { // 50 points * 3 coordinates
                    positions.splice(0, 3); // Remove oldest point
                }
                
                // Update the trail geometry
                if (positions.length >= 6) { // At least 2 points
                    const positionAttribute = trail.geometry.attributes.position;
                    
                    // Copy positions to the buffer
                    for (let i = 0; i < positions.length && i < positionAttribute.array.length; i++) {
                        positionAttribute.array[i] = positions[i];
                    }
                    
                    // Update the geometry
                    positionAttribute.needsUpdate = true;
                    trail.geometry.setDrawRange(0, Math.floor(positions.length / 3));
                    
                    // Debug first trail
                    if (positions.length === 6) {
                        console.log(`Trail visible for ${satellite.userData.id}, points: ${Math.floor(positions.length / 3)}`);
                    }
                }
            }
        }
        
        function updateCameraControls() {
            const moveSpeed = cameraControls.fast ? 0.5 : 0.2;
            
            // Movement
            if (cameraControls.forward) {
                const forward = new THREE.Vector3(0, 0, -1);
                forward.applyQuaternion(camera.quaternion);
                camera.position.add(forward.multiplyScalar(moveSpeed));
            }
            if (cameraControls.backward) {
                const backward = new THREE.Vector3(0, 0, 1);
                backward.applyQuaternion(camera.quaternion);
                camera.position.add(backward.multiplyScalar(moveSpeed));
            }
            if (cameraControls.left) {
                const left = new THREE.Vector3(-1, 0, 0);
                left.applyQuaternion(camera.quaternion);
                camera.position.add(left.multiplyScalar(moveSpeed));
            }
            if (cameraControls.right) {
                const right = new THREE.Vector3(1, 0, 0);
                right.applyQuaternion(camera.quaternion);
                camera.position.add(right.multiplyScalar(moveSpeed));
            }
            if (cameraControls.up) {
                camera.position.y += moveSpeed;
            }
            if (cameraControls.down) {
                camera.position.y -= moveSpeed;
            }
        }
        
        function failSatellite(satellite) {
            satellite.userData.status = 'failed';
            satellite.userData.health = 0;
            
            // Change status light to red and trail color
            satellite.userData.statusLight.material.color.setHex(0xff3333);
            satellite.userData.trail.material.color.setHex(0xff3333);
            
            updateSatelliteCount();
            console.log(`Satellite ${satellite.userData.id} has failed!`);
        }
        
        function updateSatelliteCount() {
            const operational = satellites.filter(s => s.userData.status === 'operational').length;
            const failed = satellites.filter(s => s.userData.status === 'failed').length;
            
            document.getElementById('satellite-count').textContent = `Active Satellites: ${operational}`;
            document.getElementById('failed-count').textContent = `Failed Satellites: ${failed}`;
        }
        
        // Event handlers
        function onMouseClick(event) {
            // Only process clicks if we weren't dragging
            if (isDragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(satellites, true);
            
            if (intersects.length > 0) {
                const satellite = intersects[0].object.parent;
                selectedSatellite = satellite;
                showSatelliteInfo(satellite);
            }
        }
        
        function onMouseDown(event) {
            mousePressed = true;
            isDragging = false;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseUp(event) {
            mousePressed = false;
            isDragging = false;
        }
        
        function onMouseMove(event) {
            if (!mousePressed) return;
            
            const deltaX = event.clientX - lastMouseX;
            const deltaY = event.clientY - lastMouseY;
            
            // If movement is significant, we're dragging
            if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                isDragging = true;
            }
            
            if (freeMode) {
                // Free mode - use existing controls
            cameraRotation.y -= deltaX * 0.005;
            cameraRotation.x -= deltaY * 0.005;
            
            // Limit vertical rotation
            cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
            
            // Apply rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotation.y;
            camera.rotation.x = cameraRotation.x;
            } else {
                // Global solar system spinning
                globalCameraAngleY -= deltaX * 0.01;
                globalCameraAngleX -= deltaY * 0.01;
                
                // Limit vertical rotation
                globalCameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, globalCameraAngleX));
                
                updateGlobalCameraPosition();
            }
            
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseWheel(event) {
            event.preventDefault();
            
            if (freeMode) {
                // Free mode - move camera forward/backward
                const zoomDirection = new THREE.Vector3(0, 0, -1);
                zoomDirection.applyQuaternion(camera.quaternion);
                const zoomAmount = event.deltaY * 0.01;
                camera.position.add(zoomDirection.multiplyScalar(zoomAmount));
            } else {
                // Global zoom
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                globalCameraDistance *= zoomFactor;
                globalCameraDistance = Math.max(10, Math.min(800, globalCameraDistance));
                updateGlobalCameraPosition();
            }
        }
        
        function updateGlobalCameraPosition() {
            // Calculate camera position based on spherical coordinates
            const x = globalCameraDistance * Math.cos(globalCameraAngleX) * Math.cos(globalCameraAngleY);
            const y = globalCameraDistance * Math.sin(globalCameraAngleX);
            const z = globalCameraDistance * Math.cos(globalCameraAngleX) * Math.sin(globalCameraAngleY);
            
            camera.position.set(x, y, z);
            camera.lookAt(globalCameraTarget);
        }
        
        function onKeyDown(event) {
            switch(event.code) {
                case 'KeyW': cameraControls.forward = true; break;
                case 'KeyS': cameraControls.backward = true; break;
                case 'KeyA': cameraControls.left = true; break;
                case 'KeyD': cameraControls.right = true; break;
                case 'KeyQ': cameraControls.up = true; break;
                case 'KeyE': cameraControls.down = true; break;
                case 'ShiftLeft': case 'ShiftRight': cameraControls.fast = true; break;
                case 'Space': 
                    event.preventDefault();
                    resetCameraView();
                    break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.code) {
                case 'KeyW': cameraControls.forward = false; break;
                case 'KeyS': cameraControls.backward = false; break;
                case 'KeyA': cameraControls.left = false; break;
                case 'KeyD': cameraControls.right = false; break;
                case 'KeyQ': cameraControls.up = false; break;
                case 'KeyE': cameraControls.down = false; break;
                case 'ShiftLeft': case 'ShiftRight': cameraControls.fast = false; break;
            }
        }
        
        function resetCameraView() {
            setCameraPreset(2); // Reset to Earth Close view
        }
        
        // Touch event handlers
        function onTouchStart(event) {
            event.preventDefault();
            
            touchCount = event.touches.length;
            
            if (touchCount === 1) {
                // Single touch - look around
                const touch = event.touches[0];
                touchStart.x = touch.clientX;
                touchStart.y = touch.clientY;
                isTouching = true;
            } else if (touchCount === 2) {
                // Two finger pinch - zoom
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                initialPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
            }
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            
            if (touchCount === 1 && isTouching) {
                // Single touch - rotate camera
                const touch = event.touches[0];
                const deltaX = touch.clientX - touchStart.x;
                const deltaY = touch.clientY - touchStart.y;
                
                if (freeMode) {
                    // Free mode - use existing controls
                cameraRotation.y -= deltaX * 0.01;
                cameraRotation.x -= deltaY * 0.01;
                
                // Limit vertical rotation
                cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                
                // Apply rotation
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraRotation.y;
                camera.rotation.x = cameraRotation.x;
                } else {
                    // Global solar system spinning
                    globalCameraAngleY -= deltaX * 0.01;
                    globalCameraAngleX -= deltaY * 0.01;
                    
                    // Limit vertical rotation
                    globalCameraAngleX = Math.max(-Math.PI/2, Math.min(Math.PI/2, globalCameraAngleX));
                    
                    updateGlobalCameraPosition();
                }
                
                touchStart.x = touch.clientX;
                touchStart.y = touch.clientY;
            } else if (touchCount === 2) {
                // Two finger pinch - zoom
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                currentPinchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                const zoomDelta = (currentPinchDistance - initialPinchDistance) * 0.01;
                
                if (freeMode) {
                    // Free mode - move camera forward/backward
                const zoomDirection = new THREE.Vector3(0, 0, -1);
                zoomDirection.applyQuaternion(camera.quaternion);
                camera.position.add(zoomDirection.multiplyScalar(zoomDelta));
                } else {
                    // Global zoom
                    const zoomFactor = zoomDelta > 0 ? 1.05 : 0.95;
                    globalCameraDistance *= zoomFactor;
                    globalCameraDistance = Math.max(20, Math.min(500, globalCameraDistance));
                    updateGlobalCameraPosition();
                }
                
                initialPinchDistance = currentPinchDistance;
            }
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            
            touchCount = event.touches.length;
            
            if (touchCount === 0) {
                isTouching = false;
                
                // Check for tap to select satellite
                if (!autoCamera && event.changedTouches.length === 1) {
                    const touch = event.changedTouches[0];
                    const timeDiff = Date.now() - (touchStart.time || 0);
                    const moveDiff = Math.abs(touch.clientX - touchStart.x) + Math.abs(touch.clientY - touchStart.y);
                    
                    // If it was a quick tap with minimal movement
                    if (timeDiff < 300 && moveDiff < 10) {
                        mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                        
                        raycaster.setFromCamera(mouse, camera);
                        const intersects = raycaster.intersectObjects(satellites, true);
                        
                        if (intersects.length > 0) {
                            const satellite = intersects[0].object.parent;
                            selectedSatellite = satellite;
                            showSatelliteInfo(satellite);
                        }
                    }
                }
            }
            
            touchStart.time = Date.now();
        }
        
        function showSatelliteInfo(satellite) {
            const info = document.getElementById('selected-info');
            const data = satellite.userData;
            const statusClass = data.status === 'failed' ? 'status-fail' : 
                               data.type.includes('COMM') ? 'status-comm' :
                               data.type.includes('NAV') ? 'status-nav' :
                               data.type.includes('WEATHER') ? 'status-weather' :
                               data.type.includes('MILITARY') ? 'status-military' : '';
            
            info.innerHTML = `
                <strong>SATELLITE INFO</strong><br>
                ID: ${data.id}<br>
                Type: <span class="${statusClass}">${data.class.name}</span><br>
                Altitude: ${(data.orbitRadius * 6371).toFixed(0)} km<br>
                Inclination: ${data.inclination.toFixed(1)}¬∞<br>
                Status: <span class="${statusClass}">${data.status.toUpperCase()}</span><br>
                Health: ${data.health}%<br>
                Speed: ${(data.class.speed * 100).toFixed(2)}¬∞/frame
            `;
        }
        
        // Control functions
        function togglePause() {
            paused = !paused;
            const btn = event.target;
            btn.textContent = paused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
        }
        
        function resetSimulation() {
            // Reset all simulation variables
            paused = false;
            showOrbits = true;
            showTrails = false;
            freeMode = false;
            followEarth = false;
            negativeLighting = false;
            simulationSpeed = 1.0;
            earthOrbitAngle = 0;
            moonOrbitAngle = 0;
            highlightedSatellites = [];
            currentCameraPreset = 2;
            
            // Reset Earth and Moon positions
            earthSystem.position.set(50, 0, 0);
                moon.position.set(15, 0, 0); // Updated to match new Moon distance
            earth.rotation.y = 0;
            
            // Reset planet positions and angles
            Object.keys(planetData).forEach(planetKey => {
                const data = planetData[planetKey];
                const planet = planets[planetKey];
                if (planet) {
                    planetAngles[planetKey] = Math.random() * Math.PI * 2;
                    planet.position.x = Math.cos(planetAngles[planetKey]) * data.distance;
                    planet.position.z = Math.sin(planetAngles[planetKey]) * data.distance;
                    
                    if (planetKey === 'saturn') {
                        planet.children[0].rotation.y = 0;
                    } else {
                        planet.rotation.y = 0;
                    }
                }
            });
            
            // Reset lighting to normal
            scene.background = new THREE.Color(0x000011);
            sunLight.color.setHex(0xffffff);
            
            // Restore sun colors
            sun.children.forEach((child, index) => {
                if (child.material && child.material.color) {
                    if (index === 0) { // Core
                        child.material.color.setHex(0xffff00);
                    } else { // Glow
                        child.material.color.setHex(0xffaa00);
                    }
                }
            });
            
            if (window.sunFlames) {
                const colors = [0xff4400, 0xff6600, 0xff8800, 0xffaa00, 0xffcc00];
                window.sunFlames.forEach((flame, index) => {
                    flame.material.color.setHex(colors[index] || 0xffaa00);
                    flame.scale.setScalar(1);
                    flame.rotation.set(0, 0, 0);
                });
            }
            
            // Restore stars
            if (window.starField) {
                window.starField.material.color.setHex(0xffffff);
                window.starField.material.blending = THREE.AdditiveBlending;
            }
            
            // Restore planet colors
            Object.keys(planetData).forEach(planetKey => {
                const planet = planets[planetKey];
                const data = planetData[planetKey];
                if (planet && data) {
                    if (planetKey === 'saturn') {
                        planet.children[0].material.color.setHex(data.color);
                        planet.children[1].material.color.setHex(0xffddaa);
                    } else {
                        planet.material.color.setHex(data.color);
                    }
                }
            });
            
            // Reset UI controls to default values
            document.getElementById('simulation-speed').value = 1;
            document.getElementById('speed-display').textContent = '1.0x';
            
            // Recreate satellites with default configuration
            createSatellites();
            
            // Reset camera to default Earth Close view
            setCameraPreset(2);
            lastEarthPosition.copy(earthSystem.position);
            
            // Reset global camera variables
            globalCameraDistance = 200;
            globalCameraAngleX = 0;
            globalCameraAngleY = 0;
            
            // Update all UI elements
            updatePresetButtons();
            updateFreeModeButton();
            updateFollowEarthButton();
            updateNegativeButton();
            
            // Update toggle buttons
            const orbitsBtn = document.querySelector('button[onclick="toggleOrbits()"]');
            if (orbitsBtn) orbitsBtn.textContent = showOrbits ? 'üåç ORBITS ‚úì' : 'üåç ORBITS';
            
            const trailsBtn = document.querySelector('button[onclick="toggleTrails()"]');
            if (trailsBtn) trailsBtn.textContent = showTrails ? '‚ú® TRAILS ‚úì' : '‚ú® TRAILS';
            
            // Ensure trail visibility matches showTrails state
            trails.forEach(trail => {
                trail.visible = showTrails;
            });
            
            const pauseBtn = document.querySelector('button[onclick="togglePause()"]');
            if (pauseBtn) pauseBtn.textContent = '‚è∏Ô∏è PAUSE';
            
            // Clear selection info
            document.getElementById('selected-info').textContent = 'Click satellite for details';
            
            console.log('Simulation completely reset to initial state');
        }
        
        function randomFailure() {
            const operational = satellites.filter(s => s.userData.status === 'operational');
            if (operational.length > 0) {
                const randomSat = operational[Math.floor(Math.random() * operational.length)];
                failSatellite(randomSat);
            }
        }
        
        function toggleOrbits() {
            showOrbits = !showOrbits;
            orbitalRings.forEach(ring => {
                ring.visible = showOrbits;
            });
            
            // Also toggle planetary orbits
            planetOrbits.forEach(orbit => {
                orbit.visible = showOrbits;
            });
            
            // Also toggle moon orbits
            moonOrbits.forEach(orbit => {
                orbit.visible = showOrbits;
            });
            
            // Update button text
            const btn = document.querySelector('button[onclick="toggleOrbits()"]');
            if (btn) {
                btn.textContent = showOrbits ? 'üåç ORBITS ‚úì' : 'üåç ORBITS';
            }
        }
        
        function toggleTrails() {
            showTrails = !showTrails;
            
            // Update all trail visibility
            trails.forEach(trail => {
                trail.visible = showTrails;
            });
            
            // Also update individual satellite trails
            satellites.forEach(satellite => {
                if (satellite.userData.trail) {
                    satellite.userData.trail.visible = showTrails;
                }
            });
            
            // Update button text
            const btn = document.querySelector('button[onclick="toggleTrails()"]');
            if (btn) {
                btn.textContent = showTrails ? '‚ú® TRAILS ‚úì' : '‚ú® TRAILS';
            }
        }
        
        function applySatelliteConfig() {
            // Clear all existing satellites and trails completely
            satellites.forEach(satellite => {
                // Remove satellite from earthSystem
                earthSystem.remove(satellite);
                
                // Clear trail positions array
                if (satellite.userData.trailPositions) {
                    satellite.userData.trailPositions = [];
                }
                
                // Remove trail from scene
                if (satellite.userData.trail) {
                    satellite.userData.trail.geometry.dispose();
                    satellite.userData.trail.material.dispose();
                    scene.remove(satellite.userData.trail);
                }
                
                // Dispose satellite geometry and materials
                satellite.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
            });
            
            // Clear trails array and remove from scene
            trails.forEach(trail => {
                if (trail.geometry) trail.geometry.dispose();
                if (trail.material) trail.material.dispose();
                scene.remove(trail);
            });
            
            // Clear orbital rings
            orbitalRings.forEach(ring => {
                earthSystem.remove(ring);
                if (ring.geometry) ring.geometry.dispose();
                if (ring.material) ring.material.dispose();
            });
            
            // Reset arrays
            satellites = [];
            trails = [];
            orbitalRings = [];
            highlightedSatellites = [];
            
            // Recreate everything fresh
            createOrbitalRings();
            createSatellites();
            
            console.log('Satellite configuration applied - scene reset');
        }
        
        function updateSimulationSpeed() {
            simulationSpeed = parseFloat(document.getElementById('simulation-speed').value);
            document.getElementById('speed-display').textContent = simulationSpeed.toFixed(1) + 'x';
        }
        
        function setCameraPreset(presetIndex) {
            if (presetIndex < 0 || presetIndex >= cameraPresets.length) return;
            
            currentCameraPreset = presetIndex;
            freeMode = false;
            
            const preset = cameraPresets[presetIndex];
            const newPos = preset.getPosition();
            const newTarget = preset.getTarget();
            
            camera.position.copy(newPos);
            camera.lookAt(newTarget);
            cameraRotation = { x: 0, y: 0 };
            
            // Update global camera variables to match preset position
            globalCameraTarget.copy(newTarget);
            globalCameraDistance = newPos.distanceTo(newTarget);
            
            // Calculate angles from position
            const direction = newPos.clone().sub(newTarget).normalize();
            globalCameraAngleY = Math.atan2(direction.z, direction.x);
            globalCameraAngleX = Math.asin(direction.y);
            
            updateCameraInfo();
            updatePresetButtons();
        }
        
        function toggleFreeMode() {
            freeMode = !freeMode;
            
            if (freeMode) {
                // Preserve current camera orientation when switching to free mode
                // Calculate current rotation from camera's current orientation
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                // Convert direction to euler angles
                cameraRotation.y = Math.atan2(direction.x, direction.z);
                cameraRotation.x = Math.asin(-direction.y);
            }
            
            updateCameraInfo();
            updateFreeModeButton();
        }
        
        function toggleFollowEarth() {
            followEarth = !followEarth;
            
            if (followEarth) {
                // When starting to follow Earth, record current Earth position
                lastEarthPosition.copy(earthSystem.position);
                
                // Calculate offset from camera to Earth for reference
                earthFollowOffset.copy(camera.position).sub(earthSystem.position);
            }
            
            updateCameraInfo();
            updateFollowEarthButton();
        }
        
        function updateCameraInfo() {
            const preset = cameraPresets[currentCameraPreset];
            let modeText;
            
            if (freeMode && followEarth) {
                modeText = 'Free + Follow Earth';
            } else if (freeMode) {
                modeText = 'Free Mode';
            } else if (followEarth) {
                modeText = `${preset.name} + Follow`;
            } else {
                modeText = preset.name;
            }
            
            let followText = followEarth ? 'On' : 'Off';
            
            document.getElementById('camera-info').textContent = `Camera: ${modeText}`;
            document.getElementById('camera-mode').textContent = `Mode: ${freeMode ? 'Free' : 'Preset'} | Follow: ${followText}`;
        }
        
        function updatePresetButtons() {
            for (let i = 0; i < cameraPresets.length; i++) {
                const btn = document.getElementById(`preset-${i}`);
                if (btn) {
                    btn.classList.toggle('active', i === currentCameraPreset && !freeMode);
                }
            }
        }
        
        function updateFreeModeButton() {
            const btn = document.getElementById('free-mode-btn');
            if (btn) {
                btn.classList.toggle('active', freeMode);
                btn.textContent = freeMode ? 'üéÆ FREE MODE ‚úì' : 'üéÆ FREE MODE';
            }
        }
        
        function updateFollowEarthButton() {
            const btn = document.getElementById('follow-earth-btn');
            if (btn) {
                btn.classList.toggle('active', followEarth);
                btn.textContent = followEarth ? 'üåç FOLLOW EARTH ‚úì' : 'üåç FOLLOW EARTH';
            }
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar-tray');
            const toggle = document.getElementById('sidebar-toggle');
            
            sidebar.classList.toggle('retracted');
            toggle.textContent = sidebar.classList.contains('retracted') ? '‚ñ∂' : '‚óÄ';
        }
        
        function toggleNegativeLighting() {
            negativeLighting = !negativeLighting;
            
            if (negativeLighting) {
                // Invert colors for negative effect
                scene.background = new THREE.Color(0xffffff);
                
                // Make sun dark - iterate through all children
                sun.children.forEach(child => {
                    if (child.material) {
                        if (child.material.color) {
                            child.material.color.setHex(0x000055);
                        }
                    }
                });
                
                // Dark sun flames
                if (window.sunFlames) {
                    window.sunFlames.forEach(flame => {
                        flame.material.color.setHex(0x000044);
                    });
                }
                
                // Invert lighting
                sunLight.color.setHex(0x000000);
                
                // Dark stars
                if (window.starField) {
                    window.starField.material.color.setHex(0x000000);
                    window.starField.material.blending = THREE.SubtractiveBlending;
                }
                
                // Invert planet colors
                Object.keys(planets).forEach(planetKey => {
                    const planet = planets[planetKey];
                    if (planet) {
                        if (planetKey === 'saturn') {
                            planet.children[0].material.color.setHex(0x111111);
                            planet.children[1].material.color.setHex(0x222222);
                        } else {
                            planet.material.color.setHex(0x111111);
                        }
                    }
                });
                
            } else {
                // Restore normal colors
                scene.background = new THREE.Color(0x000011);
                
                // Restore sun core
                sun.children.forEach((child, index) => {
                    if (child.material && child.material.color) {
                        if (index === 0) { // Core
                            child.material.color.setHex(0xffff00);
                        } else { // Glow
                            child.material.color.setHex(0xffaa00);
                        }
                    }
                });
                
                // Restore sun flames
                if (window.sunFlames) {
                    const colors = [0xff4400, 0xff6600, 0xff8800, 0xffaa00, 0xffcc00];
                    window.sunFlames.forEach((flame, index) => {
                        flame.material.color.setHex(colors[index] || 0xffaa00);
                    });
                }
                
                // Restore lighting
                sunLight.color.setHex(0xffffff);
                
                // Restore stars
                if (window.starField) {
                    window.starField.material.color.setHex(0xffffff);
                    window.starField.material.blending = THREE.AdditiveBlending;
                }
                
                // Restore planet colors
                Object.keys(planetData).forEach(planetKey => {
                    const planet = planets[planetKey];
                    const data = planetData[planetKey];
                    if (planet && data) {
                        if (planetKey === 'saturn') {
                            planet.children[0].material.color.setHex(data.color);
                            planet.children[1].material.color.setHex(0xffddaa);
                        } else {
                            planet.material.color.setHex(data.color);
                        }
                    }
                });
            }
            
            updateNegativeButton();
        }
        
        function updateNegativeButton() {
            const btn = document.getElementById('negative-btn');
            if (btn) {
                btn.classList.toggle('active', negativeLighting);
                btn.textContent = negativeLighting ? 'üåë NEGATIVE ‚úì' : 'üåë NEGATIVE';
            }
        }
        
        function highlightSatelliteClass(satelliteType) {
            // First unhighlight all satellites
            unhighlightAllSatellites();
            
            // Find and highlight satellites of the specified type
            satellites.forEach(satellite => {
                if (satellite.userData.type === satelliteType) {
                    highlightSatellite(satellite);
                    highlightedSatellites.push(satellite);
                }
            });
        }
        
        function highlightSatellite(satellite) {
            // Scale up the satellite
            satellite.scale.set(2.5, 2.5, 2.5);
            
            // Make the status light brighter and larger
            const statusLight = satellite.userData.statusLight;
            if (statusLight) {
                statusLight.scale.set(3, 3, 3);
                statusLight.material.opacity = 1.0;
            }
            
            // Make the trail more prominent
            const trail = satellite.userData.trail;
            if (trail && showTrails) {
                trail.material.opacity = 1.0;
                trail.material.linewidth = 3;
            }
        }
        
        function unhighlightAllSatellites() {
            highlightedSatellites.forEach(satellite => {
                // Reset scale
                satellite.scale.set(1, 1, 1);
                
                // Reset status light
                const statusLight = satellite.userData.statusLight;
                if (statusLight) {
                    statusLight.scale.set(1, 1, 1);
                    statusLight.material.opacity = 0.8;
                }
                
                // Reset trail
                const trail = satellite.userData.trail;
                if (trail) {
                    trail.material.opacity = 0.6;
                    trail.material.linewidth = 1;
                }
            });
            
            // Clear the highlighted satellites array
            highlightedSatellites = [];
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Helper function to update UI elements (referenced by API)
        function updateUI() {
            const pauseBtn = document.querySelector('button[onclick="togglePause()"]');
            if (pauseBtn) {
                pauseBtn.textContent = paused ? '‚ñ∂Ô∏è RESUME' : '‚è∏Ô∏è PAUSE';
            }
        }
        
        // Initialize the simulation when page loads
        window.addEventListener('load', function() {
            init();
            
            // Initialize slider value displays and event listeners
            const sliders = [
                { id: 'leo-comm', valueId: 'leo-comm-value' },
                { id: 'weather', valueId: 'weather-value' },
                { id: 'nav', valueId: 'nav-value' },
                { id: 'geo-comm', valueId: 'geo-comm-value' },
                { id: 'military', valueId: 'military-value' }
            ];
            
            sliders.forEach(slider => {
                const sliderElement = document.getElementById(slider.id);
                const valueElement = document.getElementById(slider.valueId);
                
                if (sliderElement && valueElement) {
                    // Set initial value
                    valueElement.textContent = sliderElement.value;
                    
                    // Add event listener to update value display
                    sliderElement.addEventListener('input', function() {
                        valueElement.textContent = this.value;
                    });
                }
            });
        });
    </script>
    
    <!-- Theme System -->
    <script src="themes.js"></script>
    
    <!-- Satellite Solar Simulation API -->
    <script src="sat-sol-sim.js"></script>
</body>
</html>